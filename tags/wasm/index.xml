<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wasm on CharlyCst</title>
    <link>https://charlycst.github.io/tags/wasm/</link>
    <description>Recent content in Wasm on CharlyCst</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 21 Dec 2020 10:03:08 +0100</lastBuildDate>
    
	<atom:link href="https://charlycst.github.io/tags/wasm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Building a Memory Allocator for WebAssembly</title>
      <link>https://charlycst.github.io/posts/wasm-memory-allocator/</link>
      <pubDate>Mon, 21 Dec 2020 10:03:08 +0100</pubDate>
      
      <guid>https://charlycst.github.io/posts/wasm-memory-allocator/</guid>
      <description>While waiting for the GC proposal, the only way to request memory in WebAssembly is to allocate it for ourselves from the linear memory. Memory allocation and management is a huge topic in computer science, but in this post we will focus on a simple design: the linked list allocators.
Building an efficient allocator is notoriously hard, as testifies the popular jemalloc which is famously known for its 30,000 lines of codes.</description>
    </item>
    
    <item>
      <title>Wasm binary encoding</title>
      <link>https://charlycst.github.io/posts/wasm-encoding/</link>
      <pubDate>Fri, 12 Jun 2020 08:00:00 +0100</pubDate>
      
      <guid>https://charlycst.github.io/posts/wasm-encoding/</guid>
      <description>Lately I have been working on my own compiler (for fun &amp;amp; glory) targeting WebAssembly. The inner working of a compiler is well documented and there are plenty of production-grade examples to look at (for instance this book and the rustc dev guide), but when it comes down to writing bytes one after the other the only thing you can hold onto is the specification.
Don&amp;rsquo;t get me wrong, the specification is great, but it may be a little rough at first.</description>
    </item>
    
    <item>
      <title>Speeding up pattern matching with WebAssembly</title>
      <link>https://charlycst.github.io/posts/speeding-up-pattern-matching/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://charlycst.github.io/posts/speeding-up-pattern-matching/</guid>
      <description>I while ago I was tasked to find predefined patterns in strings, a well known problem in computer science. Our algorithm was running on AWS Lambda using the Node.js runtime, and, considering that we sometimes needed to search through billions of strings, performances of this algorithm were crucial.
On the other hand I recently paid a lot of attention to WebAssembly and Rust, both technologies seem really promising and attract a growing interest from developers.</description>
    </item>
    
  </channel>
</rss>