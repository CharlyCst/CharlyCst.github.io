<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Charly Castes</title>
        <link>https://charlycst.github.io/posts/</link>
        <description>Recent content in Posts on Charly Castes</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 09 Feb 2020 15:27:06 +0100</lastBuildDate>
        <atom:link href="https://charlycst.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Speeding up pattern matching with WebAssembly</title>
            <link>https://charlycst.github.io/posts/speeding-up-pattern-matching/</link>
            <pubDate>Sun, 09 Feb 2020 15:27:06 +0100</pubDate>
            
            <guid>https://charlycst.github.io/posts/speeding-up-pattern-matching/</guid>
            <description>I while ago I was tasked to find predefined patterns in strings, a well known problem in computer science. Our algorithm was running on AWS Lambda using the Node.js runtime, and, considering that we sometimes needed to search through billions of strings, performances of this algorithm were crucial.
On the other hand I recently paid a lot of attention to WebAssembly and Rust, both technologies seem really promising and attract a growing interest from developers.</description>
            <content type="html"><![CDATA[<p>I while ago I was tasked to find predefined patterns in strings, a well known problem in computer science. Our algorithm was running on AWS Lambda using the Node.js runtime, and, considering that we sometimes needed to search through billions of strings, performances of this algorithm were crucial.</p>
<p>On the other hand I recently paid a lot of attention to WebAssembly and Rust, both technologies seem really promising and attract a growing interest from developers. After reading a few articles on performance improvement using Wasm (the acronym for WebAssembly), I decided to give it a try: could it speed up my Lambda function?</p>
<h2 id="pattern-matching">Pattern matching</h2>
<p>Before even talking about WebAssembly, let&rsquo;s dig a bit into the pattern searching problem: We are given a set of patterns and a string, and the goal is to find all patterns that appear in the string.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// Patterns
</span><span style="color:#75715e"></span>[<span style="color:#e6db74">&#34;Charizard&#34;</span>, <span style="color:#e6db74">&#34;Magikarp&#34;</span>, <span style="color:#e6db74">&#34;Splash&#34;</span>, <span style="color:#e6db74">&#34;Flamethrower&#34;</span>];

<span style="color:#75715e">// The string
</span><span style="color:#75715e"></span><span style="color:#e6db74">&#34;Magikarp used Splash! But nothing happened.&#34;</span>[
  <span style="color:#75715e">/*^^^^^^^^      ^^^^^^                       */</span>

  <span style="color:#75715e">// Output
</span><span style="color:#75715e"></span>  (<span style="color:#e6db74">&#34;Magikarp&#34;</span>, <span style="color:#e6db74">&#34;Splash&#34;</span>)
];
</code></pre></div><p>When looking for only one pattern the problem is simple: go through the string character per character and if the current one matches the first character of the pattern, then we compare the next caracter to the second of the pattern and so on. This can be represented using an automaton:</p>

    <figure class="left" >
        <img src="/img/speedingUpPatternMatching/linearAutomaton.png"  alt="A linear automaton"   class="rounded"/>

        
    </figure>


<p>Regular expressions (regexes) are an extension of this algorithm, where the automaton can be more evolved:</p>

    <figure class="left" >
        <img src="/img/speedingUpPatternMatching/regex.png"  alt="Example of regex"   class="rounded"/>

        
    </figure>


<p>In the example above, the regex is equivalent to searching for both patterns &ldquo;charmander&rdquo; and &ldquo;charizard&rdquo;. Of course, regexes are very expressive and can match much more complex patterns, but in this article we are only interested in plain text patterns.</p>
<p>Trying to write a single regex to match a thousand patterns or using a thousand regexes is probably not a good idea, however. For those use cases there is another algorithm much more effective called <a href="https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm">Aho-Corasick</a>.</p>
<p>The idea is to build a deterministic finite automaton (meaning that there is always exactly one possibility when transitioning from one state to another) that takes advantages of common suffixes and prefixes.</p>
<p>The Aho-Corasick algorithm uses a &lsquo;failure function&rsquo;: for a given state if no transition corresponds to the next character, the failure function kicks in and tell us which is the next state.</p>

    <figure class="left" >
        <img src="/img/speedingUpPatternMatching/automaton.png"  alt="Example of Aho-Corasick failure function"   class="rounded"/>

        
    </figure>


<p>For instance in the above example, after recognizing <code>lapra</code> of <code>lapras</code>, if the next character is not an <code>s</code>, then no need to go back and try other branches of the automaton: the failure function tells us that we can continue from the first <code>a</code> state of <code>rapidash</code>. Again if the next character is not a <code>p</code>, we can continue from <code>a</code> state of <code>articuno</code> and so on.</p>
<p>If you are interested in how to build the automaton, you can find a commented implementation in C++ <a href="https://www.geeksforgeeks.org/aho-corasick-algorithm-pattern-searching/">here</a>. If you prefer Rust, I wrote a (less commented) <a href="https://github.com/CharlyCst/fast-match/blob/master/src/lib.rs">Rust version</a> for the sake of this experiment.</p>
<p>From a practical point of view, the Aho-Corasick algorithm consist in two phases:</p>
<ul>
<li>Building the automaton: in linear time, performances of this step are not critical and building time will be neglected by comparison to the execution step.</li>
<li>Executing the automaton: this is the phase I&rsquo;m interested in, it is mainly about look up into the transition and failure function tables built at the previous step.</li>
</ul>
<p>What is interesting is that this task does not involve heavy computation as graphic or cryptography may require, which would be the type of tasks that make WebAssembly shine: still, can Wasm speed-up pattern matching?</p>
<h2 id="speeding-things-up">Speeding things up</h2>
<p>Now that we are up to date with the algorithm, <a href="https://www.npmjs.com/package/ahocorasick">here</a> is a good JavaScript implementation that I used as reference. The plan was to write a Rust version, compile it to Wasm and check if it is faster.</p>
<p>In order to compare performances I needed to create a benchmark. I picked a little over 8,000 distinct random words from <a href="https://en.wikipedia.org/wiki/Les_Mis%C3%A9rables">Les Misérables</a>, a 68,000 lines long novel by <a href="https://en.wikipedia.org/wiki/Victor_Hugo">Victor Hugo</a>. The task is to find all occurrences of these 8,000 words in the whole novel.</p>
<h3 id="a-failed-attempt">A failed attempt</h3>
<p>I wrote a first version of Aho-Corasick in Rust using <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a> to generate glue code between JavaScript and WebAssembly.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[</span><span style="color:#75715e">wasm_bindgen</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Matcher</span> {
	...
}

<span style="color:#75715e">#[</span><span style="color:#75715e">wasm_bindgen</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">impl</span> Matcher {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(words: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">js_sys</span>::Array) -&gt; <span style="color:#a6e22e">Matcher</span> {
        ...
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self, string: String) -&gt; <span style="color:#a6e22e">js_sys</span>::Array {
        ...
    }
}
</code></pre></div><p>I built a release build targeting Node.js</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">wasm-pack build --release --target nodejs
</code></pre></div><p>Then timed both je JavaScript and WebAssembly version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">time NODE_ENV<span style="color:#f92672">=</span>production node wasm.js
time NODE_ENV<span style="color:#f92672">=</span>production node js.js
</code></pre></div><p>And surprise:</p>

    <figure class="left" >
        <img src="/img/speedingUpPatternMatching/firstComparison.png"  alt="JS vs Wasm execution time"   class="rounded"/>

        
    </figure>


<p>It turned out that my Wasm version was 5 times slower. I sort of knew that I should have expected that, but still, I was somewhat disappointed.</p>
<p>Before jumping on any conclusions it is often a good idea to check what really happens under the hood: V8 (and thus Node.js) has some good profiling tools built in, you can use them as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># pass the `prof` option to Node.js</span>
node --prof wasm.js

<span style="color:#75715e"># This will generate a .log file, in my case isolate-0x49a1aa0-11836-v8.log</span>
<span style="color:#75715e"># This file can be used to generate a profile:</span>
node --prof-process isolate-0x49a1aa0-11836-v8.log
</code></pre></div><p>Here is the summary for the JavaScript version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> <span style="color:#f92672">[</span>Summary<span style="color:#f92672">]</span>:
   ticks  total  nonlib   name
   <span style="color:#ae81ff">2236</span>   41.2%   95.6%  JavaScript
    <span style="color:#ae81ff">103</span>    1.9%    4.4%  C++
     <span style="color:#ae81ff">59</span>    1.1%    2.5%  GC
   <span style="color:#ae81ff">3082</span>   56.9%          Shared libraries
</code></pre></div><p>And the Wasm version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> <span style="color:#f92672">[</span>Summary<span style="color:#f92672">]</span>:
   ticks  total  nonlib   name
   <span style="color:#ae81ff">5949</span>   20.2%   37.0%  JavaScript
   <span style="color:#ae81ff">9405</span>   32.0%   58.5%  C++
   <span style="color:#ae81ff">1554</span>    5.3%    9.7%  GC
  <span style="color:#ae81ff">13326</span>   45.3%          Shared libraries
    <span style="color:#ae81ff">712</span>    2.4%          Unaccounted
</code></pre></div><p>The JavaScript row accounts for both JavaScript and WebAssembly code, while Shared libraries accounts mostly for Node.js built-in functions.</p>
<p>Something clearly goes wrong with my Wasm version: 32% of execution time is spent on C++ while it is only accounting for 1.9% in the JS version. You can also notice that the garbage collector (GC) is doing five time more work in Wasm that in JS.</p>
<p>Let&rsquo;s take a closer look at those categories in the case of Wasm:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> <span style="color:#f92672">[</span>JavaScript<span style="color:#f92672">]</span>:
   ticks  total  nonlib   name
   <span style="color:#ae81ff">3166</span>   10.8%   19.7%  Function: *fast_match::Matcher::run::hdc325dfd51ff7151
    <span style="color:#ae81ff">846</span>    2.9%    5.3%  LazyCompile: *module.exports.__wbindgen_string_new /home/gripsou/Documents/projects/fast-match/pkg/fast_match.js:135:48
    <span style="color:#ae81ff">687</span>    2.3%    4.3%  Function: *&lt;alloc::vec::Vec&lt;T&gt; as core::ops::deref::Deref&gt;::deref::h598faf2834c73f9f
    <span style="color:#ae81ff">183</span>    0.6%    1.1%  LazyCompile: *getEncodingOps buffer.js:644:24
    <span style="color:#ae81ff">158</span>    0.5%    1.0%  LazyCompile: *&lt;anonymous&gt; /home/gripsou/Documents/projects/fast-match/node/asm.js:9:49
    <span style="color:#ae81ff">149</span>    0.5%    0.9%  Function: *js_sys::Array::push::h20c97c9f2647281f
    <span style="color:#ae81ff">148</span>    0.5%    0.9%  LazyCompile: *module.exports.__wbg_push_446cc0334a2426e8 /home/gripsou/Documents/projects/fast-match/pkg/fast_match.js:176:54
    <span style="color:#ae81ff">107</span>    0.4%    0.7%  LazyCompile: *module.exports.__wbindgen_object_drop_ref /home/gripsou/Documents/projects/fast-match/pkg/fast_match.js:131:53
    ...
</code></pre></div><p>Most of the time spent executing my code is spent inside my Wasm <code>run</code> function responsible for executing the automaton, that&rsquo;s a good thing. Then comes the glue code generated by wasm-bindgen, it&rsquo;s JavaScript code. As indicated by the <code>LazyCompile</code> name, Node tried to compile our JS and succeeded (there is a <code>*</code>, if the code was interpreted we would have seen a <code>~</code>), so our JavaScript is fast too.</p>
<p>Up to this point things looks good, let&rsquo;s take a look at the C++:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> <span style="color:#f92672">[</span>C++<span style="color:#f92672">]</span>:
   ticks  total  nonlib   name
    <span style="color:#ae81ff">749</span>    2.5%    4.7%  _int_malloc
    <span style="color:#ae81ff">673</span>    2.3%    4.2%  __GI___libc_malloc
    <span style="color:#ae81ff">532</span>    1.8%    3.3%  __GI___pthread_mutex_lock
    <span style="color:#ae81ff">513</span>    1.7%    3.2%  node::i18n::<span style="color:#f92672">(</span>anonymous namespace<span style="color:#f92672">)</span>::ConverterObject::Decode<span style="color:#f92672">(</span>v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;<span style="color:#f92672">)</span>
    <span style="color:#ae81ff">481</span>    1.6%    3.0%  v8::internal::PrototypeIterator::Advance<span style="color:#f92672">(</span><span style="color:#f92672">)</span>
    <span style="color:#ae81ff">385</span>    1.3%    2.4%  __pthread_mutex_unlock_usercnt
    <span style="color:#ae81ff">344</span>    1.2%    2.1%  node::Buffer::Copy<span style="color:#f92672">(</span>node::Environment*, char const*, unsigned long<span style="color:#f92672">)</span>
    <span style="color:#ae81ff">332</span>    1.1%    2.1%  v8::Object::SetPrototype<span style="color:#f92672">(</span>v8::Local&lt;v8::Context&gt;, v8::Local&lt;v8::Value&gt;<span style="color:#f92672">)</span>
    <span style="color:#ae81ff">319</span>    1.1%    2.0%  void node::Buffer::<span style="color:#f92672">(</span>anonymous namespace<span style="color:#f92672">)</span>::StringSlice&lt;<span style="color:#f92672">(</span>node::encoding<span style="color:#f92672">)</span>3&gt;<span style="color:#f92672">(</span>v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;<span style="color:#f92672">)</span>
    <span style="color:#ae81ff">285</span>    1.0%    1.8%  v8::ArrayBuffer::GetContents<span style="color:#f92672">(</span><span style="color:#f92672">)</span>
</code></pre></div><p>The two first items are related to memory allocation, we also spot a buffer copy operation and some encode and decode primitives. So here we are: I was copying things in memory between JavaScript and Wasm. Note this can also explain the higher load on the GC we noticed earlier.</p>
<p>And here is the culprit:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Rust" data-lang="Rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self, string: String) -&gt; <span style="color:#a6e22e">js_sys</span>::Array {
	...
}
</code></pre></div><p>My interface between JavaScript and WebAssembly was using Rust strings, when reading <a href="https://rustwasm.github.io/docs/wasm-bindgen/reference/types/str.html">wasm-bindgen doc</a>, we can learn that not only strings are copied back and forth between JS and Wasm, but also that JavaScript is using UTF-16 and Rust UTF-8, meaning that there is an additional conversion overhead.</p>
<h2 id="fixing-things-up">Fixing things up</h2>
<p>In fact, I was aware of these copies between JavaScript and WebAssembly, but did it purposefully because I used to think that back and forth between JS and Wasm were slow, <a href="https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/">turns out that is not the case</a>.</p>
<p>What this all means is that in this case it is much better to work with JavaScript values from Rust, the <a href="https://rustwasm.github.io/wasm-bindgen/api/js_sys/index.html"><code>js-sys</code> crate</a> exposes everything that is needed for that: we can accept JavaScript string (that is a pointer to the memory hosting the string in the JS heap, no copy) and iterate over it, each character is represented by a <code>u16</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Rust" data-lang="Rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(<span style="color:#f92672">&amp;</span>self, string: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">js_sys</span>::JsString) -&gt; <span style="color:#a6e22e">js_sys</span>::Array {
	...
	<span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> string.iter() {
            ...
        }
	...
}
</code></pre></div><p>Let&rsquo;s check the performances again:</p>

    <figure class="left" >
        <img src="/img/speedingUpPatternMatching/secondComparison.png"  alt="JS vs Wasm execution time"   class="rounded"/>

        
    </figure>


<p>Yep, this time it is faster! It&rsquo;s quite impressive considering that with today&rsquo;s engines JavaScript is already really fast once JIT compiled.</p>
<p>Let&rsquo;s take a look at the profile to check if we fixed things up:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"> <span style="color:#f92672">[</span>Summary<span style="color:#f92672">]</span>:
   ticks  total  nonlib   name
   <span style="color:#ae81ff">8249</span>   84.7%   89.5%  JavaScript
     <span style="color:#ae81ff">89</span>    0.9%    1.0%  C++
     <span style="color:#ae81ff">39</span>    0.4%    0.4%  GC
    <span style="color:#ae81ff">529</span>    5.4%          Shared libraries
    <span style="color:#ae81ff">874</span>    9.0%          Unaccounted
</code></pre></div><p>That is indeed much, much better: C++ code went down from 32% to 0.9% of execution time, now Node is truly spending most of its time actually executing our JS and Wasm code! Notice that the GC has also much less work to do, even less that in the pure JS version.</p>
<p>To put things in perspective, here is a visual recap of the old and new version profiles side to side:</p>

    <figure class="left" >
        <img src="/img/speedingUpPatternMatching/profiling.png"  alt="final comparison"   class="rounded"/>

        
    </figure>


<h2 id="conclusion">Conclusion</h2>
<p>I hope you found this post interesting, if you have to remember anything from it here are some key takeaways:</p>
<ul>
<li>Wasm can indeed speed up your code, but it must be handled carefully: pay extra attention to your interfaces with JavaScript, especially if you are passing data around.</li>
<li>A profiler can help to find what is wrong with your code or confirm your hypothesis.</li>
<li>JavaScript is already fast, <a href="https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html">maybe you don&rsquo;t need Wasm to speed up your JS</a>. For similar tasks you should not expect an order of magnitude improvement by using Wasm instead of JS.</li>
</ul>
<p>To conclude here is a visual summary of the achieved results:</p>

    <figure class="left" >
        <img src="/img/speedingUpPatternMatching/finalComparison.png"  alt="final comparison"   class="rounded"/>

        
    </figure>


<p>So here is the answer: Yes, once done correctly, replacing JS with Wasm can speed up my lambda function by factor of almost 2. It is now up to you to decide whether it is worth introducing Wasm into your project, considering the task you are trying to solve.</p>
]]></content>
        </item>
        
        <item>
            <title>Let&#39;s (re)code React</title>
            <link>https://charlycst.github.io/posts/micro-react/</link>
            <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
            
            <guid>https://charlycst.github.io/posts/micro-react/</guid>
            <description>With more than 140k stars on Github at the time of writing, React is arguably one of the most used and loved web framework, but did you ever asked yourself how it works under the hood? Well you may know that there is this virtual DOM thing, and a certain reconciliation algorithm, but how do they work exactly? The best way to find out is probably to (re)code React by ourselves, let&amp;rsquo;s get started!</description>
            <content type="html"><![CDATA[<p>With more than 140k stars on Github at the time of writing, React is arguably one of the most used and loved web framework, but did you ever asked yourself how it works under the hood? Well you may know that there is this virtual DOM thing, and a certain reconciliation algorithm, but how do they work exactly? The best way to find out is probably to (re)code React by ourselves, let&rsquo;s get started!</p>
<p>But first a quick disclaimer: React is a very mature framework, it&rsquo;s the results of years of research and the actual algorithm is more evolved than the one I&rsquo;m presenting here. The core idea is the same, however, and I will point out differences worth mentioning.</p>
<h2 id="the-virtual-dom">The virtual DOM</h2>
<p>First thing first: let&rsquo;s talk about the DOM. The DOM (or Document Object Model) is a tree structure that represent the web page, it can be created from HTML:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;root&#34;</span>&gt;
  &lt;<span style="color:#f92672">h1</span>&gt;Hello, World !&lt;/<span style="color:#f92672">h1</span>&gt;
  &lt;<span style="color:#f92672">p</span>&gt;I&#39;m an HTML page&lt;/<span style="color:#f92672">p</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><p>But also through JavaScript, for instance we can update the DOM we created:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#34;root&#34;</span>);

<span style="color:#75715e">// Set the background color
</span><span style="color:#75715e"></span><span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">style</span>.<span style="color:#a6e22e">backgroundColor</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;blue&#34;</span>;

<span style="color:#75715e">// Add a new element
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">elt</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#34;b&#34;</span>);
<span style="color:#a6e22e">elt</span>.<span style="color:#a6e22e">textContent</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;I was added dynamically&#34;</span>;
<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">appendChild</span>(<span style="color:#a6e22e">elt</span>);
</code></pre></div><p>The resulting DOM will be equivalent to:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;root&#34;</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;background-color: blue;&#34;</span>&gt;
  &lt;<span style="color:#f92672">h1</span>&gt;Hello, World !&lt;/<span style="color:#f92672">h1</span>&gt;
  &lt;<span style="color:#f92672">p</span>&gt;I&#39;m an HTML page&lt;/<span style="color:#f92672">p</span>&gt;
  &lt;<span style="color:#f92672">b</span>&gt;I was added dynamically&lt;/<span style="color:#f92672">b</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><p>Updating the DOM through JavaScript is the only way to create dynamic web pages, however writing code to perform these updates can quickly become very cumbersome, that&rsquo;s where React comes in.</p>
<p>The idea is that instead of writing imperative code to update the DOM, it would be much easier to write a description of what we want and let our framework figure out which operations to perform. That&rsquo;s what React does, we provide a target DOM and the <em>reconciliation algorithm</em> will perform surgical updates on the real DOM to have it match the target.</p>
<p>The target DOM is called <em>Virtual DOM</em>, it is a simple JavaScript object, meaning that it is lightweight to create, we can update it at will or even throw it away, it will not have any impact on the actual web page.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// A virtual node
</span><span style="color:#75715e"></span>{
  <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;p&#34;</span>;
  <span style="color:#a6e22e">props</span><span style="color:#f92672">:</span> {
    <span style="color:#a6e22e">children</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;I&#39;m a virtual node!&#34;</span>;
  }
}
</code></pre></div><p>Those virtual nodes are what the virtual DOM is made of. To give a more formal definition, virtual nodes implement this interface:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span> <span style="color:#f92672">=</span> {}<span style="color:#f92672">&gt;</span> {
  <span style="color:#a6e22e">type</span>: <span style="color:#66d9ef">string</span>;
  <span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">P</span> <span style="color:#f92672">&amp;</span> { <span style="color:#a6e22e">children</span>: <span style="color:#66d9ef">VNode</span>[] <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> };
}
</code></pre></div><p>The property <code>children</code> is a little special, it represents the children of this node: you can imagine it as the inner HTML which is itself either a string or a list of other HTML elements.</p>
<p>Now the question is how do we create virtual nodes? React exposes a function <code>createElement</code> that do it for us.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">vNode</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">React</span>.<span style="color:#a6e22e">createElement</span>(<span style="color:#e6db74">&#34;h1&#34;</span>, {}, <span style="color:#e6db74">&#34;Hello, World!&#34;</span>);

<span style="color:#a6e22e">ReactDOM</span>.<span style="color:#a6e22e">render</span>(<span style="color:#a6e22e">vNode</span>, document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#34;root&#34;</span>));
</code></pre></div><p>Creating elements with the JavaScript syntax can quickly become burdensome, that is why most of the time we use <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>. JSX is just syntactic sugar, it is transpiled to a pure JavaScript equivalent using <code>React.createElement</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// Some JSX
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">vNode</span> <span style="color:#f92672">=</span> (
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;root&#34;</span>&gt;
    &lt;<span style="color:#f92672">h1</span>&gt;<span style="color:#a6e22e">Hello</span>, <span style="color:#a6e22e">World</span><span style="color:#f92672">!</span>&lt;/<span style="color:#f92672">h1</span>&gt;
    &lt;<span style="color:#f92672">p</span>&gt;<span style="color:#a6e22e">I</span><span style="color:#e6db74">&#39;m a JSX page&lt;/p&gt;
</span><span style="color:#e6db74">  &lt;/div&gt;
</span><span style="color:#e6db74">);
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">// It is translated to
</span><span style="color:#e6db74">const vNode = React.createElement(&#34;div&#34;, { id: &#34;root&#34; }, [
</span><span style="color:#e6db74">  React.createElement(&#34;h1&#34;, null, &#34;Hello, World!&#34;),
</span><span style="color:#e6db74">  React.createElement(&#34;p&#34;, null, &#34;I&#39;</span><span style="color:#a6e22e">m</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">JSX</span> <span style="color:#a6e22e">page</span><span style="color:#960050;background-color:#1e0010">&#34;</span>)
]);
</code></pre></div><p>This transpilation step can be performed by tools such as <a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx">Babel</a> or <a href="https://www.typescriptlang.org/docs/handbook/jsx.html">Typescript</a>. Fortunately it is possible to pass a custom function to be used instead of <code>React.createElement</code>, all we have to do is to create our own JSX factory.</p>
<p>Now that we learned a little more about the DOM, virtual nodes and JSX we are ready to go, let&rsquo;s code!</p>
<h2 id="virtual-nodes-and-components">Virtual nodes and components</h2>
<p>We will name our framework µReact, it will feature components with the <code>setState</code> and <code>componentDidMound</code> methods as well as full JSX support. You can find the code of this section <a href="https://github.com/CharlyCst/microReact/blob/master/src/%C2%B5React/core.ts">here</a>.</p>
<p>Let&rsquo;s first define our virtual nodes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span> <span style="color:#f92672">=</span> {}<span style="color:#f92672">&gt;</span> {
  <span style="color:#a6e22e">type</span>: <span style="color:#66d9ef">string</span>;
  <span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">P</span> <span style="color:#f92672">&amp;</span> { <span style="color:#a6e22e">children</span>: <span style="color:#66d9ef">VNode</span>[] <span style="color:#f92672">|</span> <span style="color:#66d9ef">string</span> };
  <span style="color:#a6e22e">domElt?</span>: <span style="color:#66d9ef">HTMLElement</span>;
  <span style="color:#66d9ef">class</span><span style="color:#f92672">?</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> (<span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">P</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">Component</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span><span style="color:#f92672">&gt;</span>;
  <span style="color:#a6e22e">component?</span>: <span style="color:#66d9ef">Component</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span><span style="color:#f92672">&gt;</span>;
}
</code></pre></div><p>We added a few fields:</p>
<ul>
<li><strong>domElt</strong> is a reference to the corresponding DOM element if any. We will set it once we instantiate a real DOM element corresponding to this virtual node.</li>
<li><strong>class</strong> is the constructor of the µReact component, it will be defined when the virtual node correspond to a component and not to a HTML tag.</li>
<li><strong>component</strong> is a reference to the component, if any, once it has been instantiated with the class constructor.</li>
</ul>
<p>Now we are ready to create our JSX factory. There are a few difficulties here: we need to implement the same interface as <code>React.createElement</code>, which accepts quite a lot of different types for its arguments. Let&rsquo;s break it down first:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">React</span>.<span style="color:#a6e22e">createElement</span>(<span style="color:#a6e22e">type</span>, <span style="color:#a6e22e">props</span>, <span style="color:#a6e22e">children</span>);
</code></pre></div><ul>
<li><strong>type</strong> is either a string corresponding to an HTML element type, such ad <code>&quot;div&quot;</code>, <code>&quot;h1&quot;</code> and so on, or a constructor if the JSX element correspond to a React component (that is it begins with a capital letter, such as &ldquo;App&rdquo;).</li>
<li><strong>props</strong> can be either null or any JavaScript object</li>
<li><strong>children</strong> is more complicated, it can be either a string, a number, another virtual node, a list of any of these types or even a list of list. To keep things simple we will not deal with each corner case, though it will be general enough to create interesting applications.</li>
</ul>
<p>Ok, let&rsquo;s write a function <code>createElement</code> that returns a virtual node:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createElement</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span> <span style="color:#f92672">=</span> {}<span style="color:#f92672">&gt;</span>(
  <span style="color:#a6e22e">type</span>: <span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> (<span style="color:#66d9ef">new</span> (<span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">P</span>) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">Component</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span><span style="color:#f92672">&gt;</span>),
  <span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">P</span>,
  ...<span style="color:#a6e22e">children</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">any</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">any</span><span style="color:#f92672">&gt;</span>[])[] <span style="color:#f92672">|</span> (<span style="color:#66d9ef">string</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">number</span>)[]
)<span style="color:#f92672">:</span> <span style="color:#a6e22e">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">normalizedProps</span> <span style="color:#f92672">=</span> {
    ...<span style="color:#a6e22e">props</span>,
    <span style="color:#a6e22e">children</span>: <span style="color:#66d9ef">isVNodeArray</span>(<span style="color:#a6e22e">children</span>) <span style="color:#f92672">?</span> <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">children</span>) <span style="color:#f92672">:</span> <span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">children</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>
  };

  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">type</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
    <span style="color:#75715e">// It is an html element
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> { <span style="color:#a6e22e">type</span>: <span style="color:#66d9ef">type</span>, <span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">normalizedProps</span> };
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#75715e">// It is a component
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> { <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">normalizedProps</span>, <span style="color:#66d9ef">class</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">type</span> };
  }
}
</code></pre></div><p>Don&rsquo;t be scared by the types, I have done my best to keep things simple, but you know some times it just gets ugly. The two functions <code>isVNodeArray</code> and <code>flatten</code> are used to normalize the props, <code>children</code> will be either a string or a flat array of VNodes. You can find them in the full code <a href="https://github.com/CharlyCst/microReact/blob/e1c1e08491a181aa034a117354addd706b05486b/src/%C2%B5React/core.ts#L74">here</a>.</p>
<p>Maybe you noticed that <code>type</code> expect either a string or a <code>Component</code> constructor, but we didn&rsquo;t define the Component class yet, let&rsquo;s do it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Component</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span> <span style="color:#f92672">=</span> {}, <span style="color:#a6e22e">S</span> <span style="color:#f92672">=</span> {}<span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">abstract</span> <span style="color:#a6e22e">state</span>: <span style="color:#66d9ef">S</span>;
  <span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">P</span>;
  <span style="color:#a6e22e">_vNode</span>: <span style="color:#66d9ef">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span><span style="color:#f92672">&gt;</span>;

  <span style="color:#66d9ef">constructor</span>(<span style="color:#a6e22e">props</span>: <span style="color:#66d9ef">P</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">props</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">props</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_vNode</span> <span style="color:#f92672">=</span> {
      <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;&#34;</span>,
      <span style="color:#a6e22e">props</span><span style="color:#f92672">:</span> { ...<span style="color:#a6e22e">props</span>, <span style="color:#a6e22e">children</span><span style="color:#f92672">:</span> [<span style="color:#a6e22e">emptyVNode</span>] }
    };
  }

  <span style="color:#66d9ef">abstract</span> <span style="color:#a6e22e">render</span>()<span style="color:#f92672">:</span> <span style="color:#a6e22e">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">any</span><span style="color:#f92672">&gt;</span>;
  <span style="color:#a6e22e">componentDidMount() {</span>}

  <span style="color:#a6e22e">setState</span>(<span style="color:#a6e22e">newState</span>: <span style="color:#66d9ef">Partial</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">S</span><span style="color:#f92672">&gt;</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span> <span style="color:#f92672">=</span> { ...<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span>, ...<span style="color:#a6e22e">newState</span> };

    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newChild</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">render</span>();
    <span style="color:#75715e">// Do something with the new child
</span><span style="color:#75715e"></span>  }
}
</code></pre></div><p>It is now possible to define components by extending <code>Component</code> and defining a <code>render</code> method that returns a virtual node, that is some JSX as we are used to. We also defined <code>setState</code>, it updates the state and then call render, but for now we do nothing with the new child, we will come back to this method when talking about the <em>reconciliation algorithm</em>.</p>
<p>Now that we have our component and our JSX factory we can create a virtual DOM, let&rsquo;s try it out. First we set up our JSX transpiler (for instance Typescript here) to use our own factory:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#960050;background-color:#1e0010">/</span> <span style="color:#960050;background-color:#1e0010">t</span><span style="color:#960050;background-color:#1e0010">s</span><span style="color:#960050;background-color:#1e0010">c</span><span style="color:#960050;background-color:#1e0010">o</span><span style="color:#960050;background-color:#1e0010">n</span><span style="color:#960050;background-color:#1e0010">f</span><span style="color:#960050;background-color:#1e0010">i</span><span style="color:#960050;background-color:#1e0010">g</span><span style="color:#960050;background-color:#1e0010">.</span><span style="color:#960050;background-color:#1e0010">j</span><span style="color:#960050;background-color:#1e0010">s</span><span style="color:#960050;background-color:#1e0010">o</span><span style="color:#960050;background-color:#1e0010">n</span>
{
  <span style="color:#f92672">&#34;compilerOptions&#34;</span>: {
    <span style="color:#f92672">&#34;jsx&#34;</span>: <span style="color:#e6db74">&#34;react&#34;</span>,
    <span style="color:#f92672">&#34;jsxFactory&#34;</span>: <span style="color:#e6db74">&#34;µReact.createElement&#34;</span>
  }
}
</code></pre></div><p>And we can write some JSX:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-tsx" data-lang="tsx"><span style="color:#66d9ef">import</span> <span style="color:#960050;background-color:#1e0010">µ</span><span style="color:#a6e22e">React</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;./µReact&#34;</span>;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">List</span> <span style="color:#66d9ef">extends</span> <span style="color:#960050;background-color:#1e0010">µ</span><span style="color:#a6e22e">React</span>.<span style="color:#a6e22e">Component</span> {
  <span style="color:#a6e22e">render() {</span>
    <span style="color:#66d9ef">return</span> (
      <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">ul</span><span style="color:#f92672">&gt;</span>
        <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">li</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Drink</span> <span style="color:#a6e22e">apple</span> <span style="color:#a6e22e">juice</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#960050;background-color:#1e0010">l</span><span style="color:#960050;background-color:#1e0010">i</span><span style="color:#960050;background-color:#1e0010">&gt;</span>
        <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">li</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Eat</span> <span style="color:#a6e22e">vegetables</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#960050;background-color:#1e0010">l</span><span style="color:#960050;background-color:#1e0010">i</span><span style="color:#960050;background-color:#1e0010">&gt;</span>
      <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#960050;background-color:#1e0010">u</span><span style="color:#960050;background-color:#1e0010">l</span><span style="color:#960050;background-color:#1e0010">&gt;</span>
    );
  }
}

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">app</span> <span style="color:#f92672">=</span> (
  <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">div</span> <span style="color:#a6e22e">style</span><span style="color:#f92672">=</span>{{ <span style="color:#a6e22e">backgroundColor</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;#f8f8f8&#34;</span> }}<span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">List</span> <span style="color:#f92672">/</span><span style="color:#f92672">&gt;</span>
  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/</span><span style="color:#960050;background-color:#1e0010">d</span><span style="color:#960050;background-color:#1e0010">i</span><span style="color:#960050;background-color:#1e0010">v</span><span style="color:#960050;background-color:#1e0010">&gt;</span>
);

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">app</span>);
</code></pre></div><p>As expected, this code prints:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">{
  <span style="color:#a6e22e">type</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;div&#34;</span>,
  <span style="color:#a6e22e">props</span><span style="color:#f92672">:</span> {
    <span style="color:#a6e22e">style</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">backgroundColor</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;#f8f8f8&#34;</span> },
    <span style="color:#a6e22e">children</span><span style="color:#f92672">:</span> [
      {
        <span style="color:#66d9ef">class</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">List</span>
        <span style="color:#a6e22e">props</span><span style="color:#f92672">:</span> { <span style="color:#a6e22e">children</span><span style="color:#f92672">:</span> [] }
      }
    ]
  }
}
</code></pre></div><p>Notice that the <code>List</code> virtual node has no children yet, because we don&rsquo;t call <code>render</code> when instantiating the component&rsquo;s virtual node.</p>
<p>Now that we can create a virtual DOM, it&rsquo;s time to actually render it on the screen.</p>
<h2 id="the-reconciliation-algorithm">The reconciliation algorithm</h2>
<p>The <em>reconciliation algorithm</em>, also called diffing algorithm, computes the differences between two virtual DOMs and deduce a set of operations to be applied to the old DOM to have it match the new one.</p>
<p>As explained in <a href="https://reactjs.org/docs/reconciliation.html">React&rsquo;s documentation</a>, computing the smallest set of operations to transform one tree into another takes O(n³) comparisons, which is impractical. We will take the same approach as React using a simple O(n) heuristic: two different types of nodes produce different sub-trees.</p>
<p>Let&rsquo;s create our <code>diff</code> function</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">diff</span>(
    <span style="color:#a6e22e">parentDom</span>: <span style="color:#66d9ef">HTMLElement</span>,
    <span style="color:#a6e22e">newNode</span>: <span style="color:#66d9ef">VNode</span>,
    <span style="color:#a6e22e">oldNode</span>: <span style="color:#66d9ef">VNode</span>
)<span style="color:#f92672">:</span> <span style="color:#a6e22e">VNode</span> {
    ...
};
</code></pre></div><p>The algorithm is the following: we take two virtual nodes, one corresponding to the current state and another matching the desired new state. Those two nodes are sub-trees of the virtual DOM, we iterate both of them simultaneously and for each node we have several cases:</p>
<ul>
<li>If both are HTML tags we can reuse the same (real) DOM element and update its properties. We will create a function <code>updateDomProperties</code> for that. Once updated, we diff children recursively.</li>
<li>If both nodes are components of the same class, for instance two <code>&lt;App/&gt;</code>, and both have the same props then the current DOM is already up to date and there is nothing to do. Otherwise, if props are different we need to <code>render</code> the component with the most recent props, and then we recursively diff both components children.</li>
<li>In the case that they does not share the same type, for instance a <code>&lt;div&gt;</code> and a <code>&lt;p&gt;</code> or an <code>&lt;App&gt;</code> and a <code>&lt;List&gt;</code>. Then accordingly to our heuristic we decide that these two nodes will produce different subtrees, thus we destroy the old DOM subtree and instantiate a fresh one. This is also the place to call the <code>componentDidMount</code> lifecycle method.</li>
</ul>
<p>The exact code is full of implementation details, I won&rsquo;t include it in this post but you can find it <a href="https://github.com/CharlyCst/microReact/blob/master/src/%C2%B5React/diff.ts">here</a> if you want to have a look.</p>
<p>But how exactly do we iterate on children? Well the simplest possible way: we have two lists, for instance the old children may be <code>[&lt;div&gt;, &lt;List&gt;]</code> and the new <code>[&lt;div&gt;, &lt;p&gt;, &lt;List&gt;]</code>, we first diff the two <code>&lt;div&gt;</code>, then we diff the <code>&lt;List&gt;</code> and the <code>&lt;p&gt;</code> and finally because we have child left in the new list bot not in the old we instantiate a fresh DOM node accordingly. If we had more old than new children we simply destroy any remaining nodes at the end.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// Old DOM
</span><span style="color:#75715e"></span>&lt;<span style="color:#f92672">App</span>&gt;
  &lt;<span style="color:#f92672">div</span>&gt;...&lt;/<span style="color:#f92672">div</span>&gt;
  &lt;<span style="color:#f92672">List</span> /&gt;
&lt;/<span style="color:#f92672">App</span>&gt;

<span style="color:#75715e">// New DOM
</span><span style="color:#75715e"></span>&lt;<span style="color:#f92672">App</span>&gt;
  &lt;<span style="color:#f92672">div</span>&gt;...&lt;/<span style="color:#f92672">div</span>&gt;  {<span style="color:#75715e">/* Same &lt;div/&gt; as before                                  */</span>}
  &lt;<span style="color:#f92672">p</span>&gt;...&lt;/<span style="color:#f92672">p</span>&gt;      {<span style="color:#75715e">/* We destroyed &lt;List/&gt; and replaced it with a fresh &lt;p/&gt; */</span>}
  &lt;<span style="color:#f92672">List</span> /&gt;        {<span style="color:#75715e">/* A fresh &lt;List/&gt;                                        */</span>}
&lt;/<span style="color:#f92672">App</span>&gt;
</code></pre></div><p>This has some practical implications: in the previous example it would have been more efficient to create a new <code>&lt;p&gt;</code> node and to insert it between the <code>&lt;div&gt;</code> and the <code>&lt;List&gt;</code>. In fact, it will even have a visual impact because the diff operation will destroy the <code>&lt;List&gt;</code> component to create a <code>&lt;p&gt;</code> instead and then create a fresh <code>&lt;List&gt;</code>: the state will be lost. There is a way to mitigate this in React using keys, I will discuss that a little later.</p>
<p>Remember the <code>Component.setState()</code> function we created earlier? It&rsquo;s time to complete it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#a6e22e">setState</span>(<span style="color:#a6e22e">newState</span>: <span style="color:#66d9ef">Partial</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">S</span><span style="color:#f92672">&gt;</span>) {
  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span> <span style="color:#f92672">=</span> { ...<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span>, ...<span style="color:#a6e22e">newState</span> };

  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newChild</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">render</span>();
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oldChild</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_vnode</span>.<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">children</span>[<span style="color:#ae81ff">0</span>];
  <span style="color:#75715e">// We compute the difference with between the old and new child
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_vnode</span>.<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">children</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">diff</span>(
    <span style="color:#a6e22e">child</span>.<span style="color:#a6e22e">domElt</span>.<span style="color:#a6e22e">parentElement</span>,
    <span style="color:#a6e22e">newChild</span>,
    <span style="color:#a6e22e">oldChild</span>
  );
}
</code></pre></div><p>Now when updating the state of a component the virtual DOM will automatically be updated.</p>
<p>At this point we can update the virtual DOM in response to events, let&rsquo;s move on and update the <em>real</em> DOM.</p>
<h2 id="manipulate-the-dom">Manipulate the DOM</h2>
<p>We are done with the reconciliation algorithm, but we still need two other functions to have it run: <code>updateDomProperties</code> and <code>instantiate</code>. The first is responsible for adding and removing attributes of a DOM element to have it match the new desired state. The second one is needed to create fresh DOM elements.</p>
<p>Let&rsquo;s starts with updating dom properties.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">updateDomProperties</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span>, <span style="color:#a6e22e">Q</span><span style="color:#f92672">&gt;</span>(
  <span style="color:#a6e22e">dom</span>: <span style="color:#66d9ef">HTMLElement</span>,
  <span style="color:#a6e22e">newNode</span>: <span style="color:#66d9ef">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span><span style="color:#f92672">&gt;</span>,
  <span style="color:#a6e22e">oldNode</span>: <span style="color:#66d9ef">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">Q</span><span style="color:#f92672">&gt;</span>
) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">newProps</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">newNode</span>.<span style="color:#a6e22e">props</span> <span style="color:#66d9ef">as</span> { [<span style="color:#a6e22e">attr</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#a6e22e">any</span> };
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">oldProps</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">oldNode</span>.<span style="color:#a6e22e">props</span> <span style="color:#66d9ef">as</span> { [<span style="color:#a6e22e">attr</span>: <span style="color:#66d9ef">string</span>]<span style="color:#f92672">:</span> <span style="color:#a6e22e">any</span> };

  <span style="color:#75715e">// Remove no longer needed attributes and event listeners
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">attr</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">oldProps</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#a6e22e">attr</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">newProps</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">newProps</span>[<span style="color:#a6e22e">attr</span>] <span style="color:#f92672">!==</span> <span style="color:#a6e22e">oldProps</span>[<span style="color:#a6e22e">attr</span>]) {
      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isEventListener</span>(<span style="color:#a6e22e">attr</span>)) {
        <span style="color:#75715e">// For `onfoo` we need to remove the event `foo`
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">dom</span>.<span style="color:#a6e22e">removeEventListener</span>(<span style="color:#a6e22e">attr</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#ae81ff">2</span>), <span style="color:#a6e22e">oldProps</span>[<span style="color:#a6e22e">attr</span>]);
      } <span style="color:#66d9ef">else</span> {
        <span style="color:#a6e22e">dom</span>.<span style="color:#a6e22e">removeAttribute</span>(<span style="color:#a6e22e">attr</span>);
      }
    }
  }
  <span style="color:#75715e">// Add new attributes and event listeners
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">attr</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">newProps</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#a6e22e">attr</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">oldProps</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">newProps</span>[<span style="color:#a6e22e">attr</span>] <span style="color:#f92672">!==</span> <span style="color:#a6e22e">oldProps</span>[<span style="color:#a6e22e">attr</span>]) {
      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isEventListener</span>(<span style="color:#a6e22e">attr</span>)) {
        <span style="color:#a6e22e">dom</span>.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#a6e22e">attr</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#ae81ff">2</span>), <span style="color:#a6e22e">newProps</span>[<span style="color:#a6e22e">attr</span>]);
      } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">newProps</span>[<span style="color:#a6e22e">attr</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
        <span style="color:#a6e22e">dom</span>.<span style="color:#a6e22e">setAttribute</span>(<span style="color:#a6e22e">attr</span>, <span style="color:#a6e22e">newProps</span>[<span style="color:#a6e22e">attr</span>]);
      }
    }
  }
}
</code></pre></div><p>This function has been curated by removing some special cases for simplicity purposes, as always you can have a look at the full working code <a href="https://github.com/CharlyCst/microReact/blob/master/src/%C2%B5React/dom.ts">here</a>.</p>
<p>This function is rather simple, but we need to get it right: if we fail to remove an event listener, for instance a <code>onclick</code> attribute, but still add another one then both will be triggered when the user click the element.</p>
<p>We have to compose with the raw dom API here, and it does not treat all attributes as equal. For instance to set the <code>onchange</code> property (yes, <a href="https://www.w3schools.com/tags/ev_onchange.asp">it is not</a> <code>onChange</code>, you&rsquo;ve been fooled) we must first understand that it is an event listeners (because it starts with <code>on</code>) and then call <code>addEventListener</code> instead of <code>setAttribute</code> for most other properties.</p>
<p>And now let&rsquo;s write <code>instantiate</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">instantiate</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span><span style="color:#f92672">&gt;</span>(<span style="color:#a6e22e">vNode</span>: <span style="color:#66d9ef">VNode</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">P</span><span style="color:#f92672">&gt;</span>)<span style="color:#f92672">:</span> <span style="color:#a6e22e">HTMLElement</span> {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">vNode</span>.<span style="color:#66d9ef">class</span>) {
    <span style="color:#75715e">// This is a µReact Component
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">component</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">vNode</span>.<span style="color:#66d9ef">class</span>(<span style="color:#a6e22e">vNode</span>.<span style="color:#a6e22e">props</span>);
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">child</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">component</span>.<span style="color:#a6e22e">render</span>();
    <span style="color:#a6e22e">vNode</span>.<span style="color:#a6e22e">component</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">component</span>;
    <span style="color:#a6e22e">vNode</span>.<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">children</span> <span style="color:#f92672">=</span> [<span style="color:#a6e22e">child</span>];
    <span style="color:#a6e22e">component</span>.<span style="color:#a6e22e">_vNode</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">vNode</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">instantiate</span>(<span style="color:#a6e22e">child</span>);
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#75715e">// This is an HTML element
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">domElt</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">createElement</span>(<span style="color:#a6e22e">vNode</span>.<span style="color:#a6e22e">type</span>);
    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> <span style="color:#a6e22e">vNode</span>.<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">children</span> <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;string&#34;</span>) {
      <span style="color:#a6e22e">vNode</span>.<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">children</span>.<span style="color:#a6e22e">forEach</span>(<span style="color:#a6e22e">child</span> <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span>
        <span style="color:#a6e22e">domElt</span>.<span style="color:#a6e22e">appendChild</span>(<span style="color:#a6e22e">instantiate</span>(<span style="color:#a6e22e">child</span>))
      );
    }
    <span style="color:#a6e22e">updateDomProperties</span>(<span style="color:#a6e22e">domElt</span>, <span style="color:#a6e22e">vNode</span>, <span style="color:#a6e22e">emptyVNode</span>);
    <span style="color:#a6e22e">vNode</span>.<span style="color:#a6e22e">domElt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">domElt</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">domElt</span>;
  }
}
</code></pre></div><p>There are two cases:</p>
<ul>
<li>The virtual node is a component, thus it will not have any corresponding DOM element, but instead it holds a pointer to a fresh instance of its component class. It is also time to render the component for the first time, then we recursively instantiate its children.</li>
<li>The virtual node correspond to an HTML element, then we create a new DOM element, update its properties to match the virtual element&rsquo;s props and recursively instantiate its children.</li>
</ul>
<p>And we are done, we can create and maintain real DOM element. The very last thing we need is the ability to attach our DOM somewhere in the web page, that&rsquo;s the job of <code>render</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">render</span>(<span style="color:#a6e22e">vRoot</span>: <span style="color:#66d9ef">VNode</span>, <span style="color:#a6e22e">root</span>: <span style="color:#66d9ef">HTMLElement</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">null</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">root</span>) {
    <span style="color:#a6e22e">diff</span>(<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">vRoot</span>, <span style="color:#a6e22e">emptyVNode</span>);
  }
}
</code></pre></div><p>Let&rsquo;s give it a try !</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#960050;background-color:#1e0010">µ</span><span style="color:#a6e22e">React</span>.<span style="color:#a6e22e">render</span>(<span style="color:#a6e22e">App</span>, document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#34;app&#34;</span>));
</code></pre></div><p>And here is the result, a real application rendered by µReact:</p>
<div>
  <iframe src="https://charlycst.github.io/microReact/" width="100%" height="500px"></iframe>
</div>
<p>(in case the iframe didn&rsquo;t render for whatever reason, <a href="https://charlycst.github.io/microReact/">Here</a> is the link to the app)</p>
<p>So satisfying, isn&rsquo;t it? We just created our very own web framework 🎉</p>
<h2 id="some-differences-with-react">Some differences with React</h2>
<p>Obviously there are some major differences between the real React and µReact. Beside the lack of major features such as functional components, hooks, asynchronous rendering or most lifecycle methods, I will discuss two differences that I believe are worth being aware of:</p>
<ul>
<li>Keying</li>
<li>React architecture</li>
</ul>
<h4 id="keying">Keying</h4>
<p>When discussing the diffing algorithm we saw the issue of inserting new elements at the beginning or in the middle of the list of children, which is very inefficient:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx">&lt;<span style="color:#f92672">ul</span>&gt;
  &lt;<span style="color:#f92672">li</span>&gt;<span style="color:#a6e22e">Python</span>&lt;/<span style="color:#f92672">li</span>&gt;
  &lt;<span style="color:#f92672">li</span>&gt;<span style="color:#a6e22e">Go</span>&lt;/<span style="color:#f92672">li</span>&gt;
&lt;/<span style="color:#f92672">ul</span>&gt;

<span style="color:#75715e">// After inserting a new element
</span><span style="color:#75715e"></span>&lt;<span style="color:#f92672">ul</span>&gt;
  &lt;<span style="color:#f92672">li</span>&gt;<span style="color:#a6e22e">Rust</span>&lt;/<span style="color:#f92672">li</span>&gt;   {<span style="color:#75715e">/* old Python    */</span>}
  &lt;<span style="color:#f92672">li</span>&gt;<span style="color:#a6e22e">Python</span>&lt;/<span style="color:#f92672">li</span>&gt; {<span style="color:#75715e">/* old Go        */</span>}
  &lt;<span style="color:#f92672">li</span>&gt;<span style="color:#a6e22e">Go</span>&lt;/<span style="color:#f92672">li</span>&gt;     {<span style="color:#75715e">/* fresh element */</span>}
&lt;/<span style="color:#f92672">ul</span>&gt;
</code></pre></div><p>Inefficiency is a thing, but there is worse: there is actually a bug in our Todo list application. If you have at least two items in the todo list, click on the first (it then becomes yellow, its state contains <code>clicked: true</code>) and remove it (by clicking the red dot), then the second item takes the first place but becomes yellow, what happened?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx">&lt;<span style="color:#f92672">List</span>&gt;
  &lt;<span style="color:#f92672">Item</span> <span style="color:#a6e22e">text</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Drink apple juice&#34;</span>/&gt; {<span style="color:#75715e">/* clicked:true  */</span>}
  &lt;<span style="color:#f92672">Item</span> <span style="color:#a6e22e">text</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Eat vegetables&#34;</span>/&gt;    {<span style="color:#75715e">/* clicked:false */</span>}
&lt;/<span style="color:#f92672">List</span>&gt;

<span style="color:#75715e">// After deleting the first item
</span><span style="color:#75715e"></span>&lt;<span style="color:#f92672">List</span>&gt;
  &lt;<span style="color:#f92672">Item</span> <span style="color:#a6e22e">text</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Eat vegetables&#34;</span>/&gt;    {<span style="color:#75715e">/* clicked:true  */</span>}
&lt;/<span style="color:#f92672">List</span>&gt;
</code></pre></div><p>When iterating through children the algorithm will first compare <code>&lt;Item text=&quot;Drink apple juice&quot;/&gt;</code> and <code>&lt;Item text=&quot;Eat vegetables&quot;/&gt;</code> and think that you just changed the props, so it keeps the same component with the state <code>clicked:true</code>, update its props and trigger a re render.</p>
<p>A solution is to use <em>keys</em>, those are special props used by the diffing algorithm to decide if it should reuse a component or an HTML element.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx">&lt;<span style="color:#f92672">List</span>&gt;
  &lt;<span style="color:#f92672">Item</span> <span style="color:#a6e22e">key</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;aaa&#34;</span> <span style="color:#a6e22e">text</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Drink apple juice&#34;</span>/&gt; {<span style="color:#75715e">/* clicked:true  */</span>}
  &lt;<span style="color:#f92672">Item</span> <span style="color:#a6e22e">key</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bbb&#34;</span> <span style="color:#a6e22e">text</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Eat vegetables&#34;</span>/&gt;    {<span style="color:#75715e">/* clicked:false */</span>}
&lt;/<span style="color:#f92672">List</span>&gt;

<span style="color:#75715e">// After deleting the first item
</span><span style="color:#75715e"></span>&lt;<span style="color:#f92672">List</span>&gt;
  &lt;<span style="color:#f92672">Item</span> <span style="color:#a6e22e">key</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;bbb&#34;</span> <span style="color:#a6e22e">text</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Eat vegetables&#34;</span>/&gt;    {<span style="color:#75715e">/* clicked:false */</span>}
&lt;/<span style="color:#f92672">List</span>&gt;
</code></pre></div><p>Now because we used key, the diffing algorithm knows that it should reuse the second component instead of updating props of the first.</p>
<p>This is why React print a warning if you try to render a list without keys, this kind of performance issue or unexpected behavior may happen.</p>
<h4 id="react-architecture">React architecture</h4>
<p>There are a lot of react-like frameworks out there, for instance <a href="https://preactjs.com/">Preact</a> and <a href="https://infernojs.org/">Inferno</a>, they each have their own focus such as bundle size or raw speed and implement more or less of React&rsquo;s features. There is, however, one big difference between most of these frameworks and React itself: the project architecture.</p>
<p>React is modular, and if the web is of course a privileged target it is not the only one: you may have heard of <a href="https://facebook.github.io/react-native/">React Native</a> for instance. We only considered the DOM when building µReact but the <em>real</em> React is composed of a base module simply called <a href="https://github.com/facebook/react/tree/master/packages/react">React</a>, also sometime referenced as the <em>reconciler</em>, and a <em>renderer</em>, <a href="https://github.com/facebook/react/tree/master/packages/react-dom">ReactDOM</a> for the web.</p>
<p>When building an application with ReactNative, you are actually using the same code for the reconciler as you would when building a web app. The renderer, however, is different.</p>
<p>This is where things get very interesting: if one day you need to build your own UI engine, maybe for a new IoT device, embedded inside a game or whatever other platform, as long as you can embed a JavaScript engine you can use React with a custom renderer. This is very powerful because first developers already know how to create UI using React, and second you benefit from all the present and future features of React as they are added.</p>
<p>If you are interested in learning more about this, <a href="https://www.youtube.com/watch?v=CGpMlWVcHok">here</a> is a talk on the subject.</p>
<h2 id="further-reading">Further reading</h2>
<p>I hope you enjoyed this article, if you want to take a closer look at the code or discuss my implementation don&rsquo;t hesitate to do so on <a href="https://github.com/CharlyCst/microReact">github</a>.</p>
<p>Here are some readings that I found interesting while building µReact:</p>
<ul>
<li>The source code of <a href="https://github.com/preactjs/preact">Preact</a>, it is much smaller than React itself and was very helpful to understand the inner working of React like frameworks.</li>
<li><a href="https://github.com/acdlite/react-fiber-architecture">React Fiber</a>, an insight of the new React algorithm used since v16.0.0.</li>
<li>React&rsquo;s official documentation, for instance <a href="https://reactjs.org/docs/reconciliation.html">reconciliation</a> or <a href="https://reactjs.org/docs/jsx-in-depth.html">JSX</a> and some of React&rsquo;s blog posts such as &ldquo;<a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html">React Components, Elements and Instances</a>&quot;.</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
